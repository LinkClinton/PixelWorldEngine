# Tutorial 2 PixelWorld

## 目标

- 了解什么是纹理(Texture)以及纹理格式。
- 熟悉渲染编号(RenderObjectID)机制。
- 熟悉使用数据和纹理管理器(DataManager, TextureManager)。
- 了解地图(WorldMap)类型。
- 了解摄像机(Camera)类型。
- 了解世界(PixelWorld)类型。

## 纹理

简单的理解的话就是图片，但是也有不同，在引擎中，我们可以简单的将其当作位图来看。

我们可以将一张纹理大概分为3个属性，宽度(Width)，高度(Height)以及格式(Format)。简单来说，我们可以将纹理看作一个二维数组(但其本质还是一个一维数组)，那么宽度和高度就很容易理解了。而格式则可以认为为二维数组中的数据类型。

纹理格式：

- `R8G8B8A8`: 表示我们的纹理每个元素都是存储了一个4byte大小的变量，其中各个颜色分量占1byte，在引擎中通常这样的格式用来表示图片的RGBA。
- `A8`：表示我们的纹理每个元素都是存储了一个1byte大小的变量，其表示的是颜色中的Alpha分量，在引擎中通常用于表示文本纹理，即文字图片。

### 创建纹理

对于现有的图片，我们可以通过DataManager(之后会介绍)来读取图片然后解码将其转换为R8G8B8A8的格式。

而我们同样也可以从已有纹理中创建新的纹理，或者通过内存数据来创建新的纹理。

```C++
    Texture2D(Graphics* graphics, void* Data, int Width, int Height, PixelFormat PixelFormat = PixelFormat::Unknown, int MipLevels = 1);
```

- `graphics`: 图形接口，我们通过可以通过`Application::GetGraphics`获取。
- `Data`: 数据元素的头指针，注意其大小要等于高度乘以宽度再乘以每个元素的大小。
- `Width`: 纹理的宽度。
- `Height`: 纹理的高度。
- `PixelFormat`: 纹理的格式，就目前而言请设置为R8G8B8A8或者A8两种类型。
- `MipLevels`: 如果有需要就去了解MipLevel，否则设为1。

至于如何从现有纹理中创建新的纹理，请参见其另外一个构造函数。

### 合并纹理

合并纹理，在代码中是MergeTexture类型。其主要是将一些小的纹理复制后合并成一块大纹理，并且记录其渲染编号，然后再一并提交到世界中去，以方便我们进行渲染。其主要目的是为了节约资源以及提高效率。**但是需要注意的是，如果小的纹理想要加入到合并纹理中去，其纹理格式必须一致。**

```C++
    MergeTexture* mergeTexture = new MergeTexture(Application, Width, Height, PixelFormat);

    ...

    mergeTexture->AddTexture(RenderObjectID, PositionX, PositionY, SubTexture);
```

- `Application`: 应用程序。
- `Width`：合并纹理的宽度，一般来说请考虑好有哪些纹理会被复制到合并纹理中去。
- `Height`: 合并纹理的高度，一般来说请考虑好有哪些纹理会被复制到合并纹理中去。
- `PixelFormat`: 像素格式，注意合并纹理的像素格式要和被合并纹理的像素格式一致。
- `RenderObjectID`: 被合并的纹理他对应的渲染编号，但是请不要设置为0。
- `PositionX`：被合并的纹理的左上角的X坐标对应的合并纹理的X坐标。
- `PositionY`: 被合并的纹理的左上角的Y坐标对应的合并纹理的Y坐标。
- `SubTexture`: 要被合并的纹理。

即我们将我们的纹理复制到合并纹理的一块区域(Left = PositionX, Top = PositionY, Right = PositionX + SubTexture.Width - 1, Bottom = PositionY + SubTexture.Height - 1)。**如果这一块区域和已经加入到合并纹理中去的纹理所占用的区域有重合的话，那么这次合并将无效，且如果使用相同的渲染编号的话，后果将会未知。**

## 渲染编号

无论是世界中的物体还是地图块，他们本身是不可见的，当我们指定了他们使用的纹理后，我们将会将纹理渲染出来，来作为他们的可视部分。因此我们需要为他们指定使用的纹理。我们并不直接将纹理设置到物体或者地图块上，而是使用一个渲染编号来实现。

在讲到合并纹理的时候，我们提到纹理加入到合并纹理中去的时候必须设置好渲染编号，但是不能设置为0。这是因为0表示不渲染，因此我们的渲染编号要避免0整个编号，除非你本身就不想渲染。

## 数据管理器和纹理管理器

数据管理器主要是负责读取文件以及输出文件，而如果我们想要使用现有的图片资源的话，那么我们可以简单的使用数据管理器来进行读取，从而避免了自己去进行读取以及解码然后创建纹理的过程。**但是目前我们只支持读取`.png`,`.jpeg`,`.bmp`格式的图片。**

```C++
    auto texture = dataManager->RegisterTexture(FilePath);
```

- `FilePath`: 即文件的路径。

而如果我们想要释放纹理的话，请不要直接调用`delete`将纹理释放，而是使用`DataManager::UnRegisterTexture`释放我们已经读取的纹理。

纹理管理器主要是关联我们的合并纹理以及我们的世界的，当世界想要将物体以及地图渲染出来的时候，我们必须要知道他们使用的渲染编号对应的纹理，因此我们就需要用到我们的纹理管理器。

之前我们也提到，纹理在加入到合并纹理的时候就已经确定了渲染编号，但是可能我们需要使用多张合并纹理，因此我们不能直接将合并纹理设置到世界中去，而是设置到纹理管理器，然后将纹理管理器和世界关联起来。

```C++
    textureManager->AddMergeTexture(WhichSlot, MergeTexture);
```

- `WhichSlot`: 表示我们设置哪个槽的合并纹理。这是因为我们支持多张合并纹理，因此不同的合并纹理我们需要设置到不同的槽位。如果设置的槽位已经有了合并纹理，那么将会被新设置的取代。且我们最多设置的槽位范围在[0, MAX_MERGETEXTURE_COUNT - 1]范围内。
- `MergeTexture`: 要设置的合并纹理。

## 地图

地图类型仅仅只是描述我们的地图的属性，例如一个地图块使用的渲染编号，它的不透明度以及他是否能够移动等功能。

地图大致有4个较为重要的属性。

- `Width`: 地图的宽度，即地图块的在X轴方向的个数。
- `Height`: 地图的高度，即地图块在Y轴方向的个数。
- `MapBlockSize`：即每个地图块的大小，所有的地图块的大小一致，且都是正方形。
- `MapData`: 即每个地图块的属性，地图块的属性可以不一样。

### 地图块

地图由多个地图块组成，而不同的地图块也有不同的属性，这里我们介绍地图块的属性。

- `RenderObjectID`: 地图块使用的渲染编号。
- `MoveEnable`：能否移动到这一块内，主要是用于限制PixelObject的移动，以后会介绍。
- `Opacity`: 地图块的不透明度。

### 创建地图

我们可以使用构造函数来创建我们的地图，我们可以预先设置好地图数据再创建，也可以创建好后再去设置地图数据。**但是请注意我们的地图只会保存地图块的指针，因此请保证设置的地图块数据所在的内存空间在地图使用的时候不会被销毁。**

```C++
    worldMap = new WorldMap(WorldMapName, Width, Height, MapBlockSize, MapData);
```

大部分参数我们都已经介绍过了，因此这里不详细介绍了，只是需要注意`MapData`是一个一维数组，其元素类型是`MapData*`。

### 设置地图数据

如果我们想要设置地图数据的话，只需要提供我们想要设置的地图块的位置，以及数据信息即可。

```C++
    worldMap->SetMapData(X, Y, MapData);
```

- `X`: 表示地图块的X坐标。
- `Y`: 表示地图块的Y坐标。
- `MapData`: 存储地图块数据的内存的头指针，注意保持其生命周期。

## 摄像机

我们的呈现窗口大小有限，但是我们的世界可以很大，因此未必我们的窗口能够将整个世界呈现出来，通常可能只能够呈现出一部分，因此我们就需要使用摄像机来决定我们的可视范围。

创建一个摄像机是非常的简单的，我们只需要提供我们的可视范围即可。

```C++
    Camera camera = Camera(Left, Top, Right, Bottom);
```

- `Left`: 可视范围的左上角的X坐标。
- `Top`: 可视范围左上角的Y坐标。
- `Right`: 可视范围右下角的X坐标。
- `Bottom`: 可视范围右下角的Y坐标。

我们仅仅只需要提供这些参数就可以创建一个摄像机，但是同样需要注意保持摄像机的生命周期，即在使用的时候，其所在的内存空间不会被释放。

## 世界

世界是整个引擎的核心部分，他管理了我们所有物体以及地图块，我们如果想要加入物体或者设置地图，都必须通过他才能够做到。而我们通常分为以下步骤。

### 创建世界

```C++
    PixelWorld* world = new PixelWorld(PixelWorldName, Application);
```

- `PixelWorldName`: 即世界的名字，请不要重复。
- `Application`: 应用程序。

### 设置分辨率

创建好世界后，我们需要设置使用的分辨率。分辨率和具体的游戏世界没有任何关系，其主要作用是清晰度的问题，以及长宽比的问题，如果分辨率的长宽比和窗口的长宽比不同，那么我们将会在窗口的一部分构建出黑边(即不渲染的部分)，使得我们进行缩放的时候长宽比不变。这样的情况通常在全屏的时候容易出现。

```C++
    world->SetResolution(Width, Height);
```

上面两个参数主要是分辨率的宽度以及高度。

### 设置摄像机

如果我们想要看到世界中的物体的话，就必须设置好摄像机。

```C++
    world->SetCamera(Camera);
```

上面的参数是摄像机的地址，需要注意保持摄像机的生命周期。

### 设置纹理管理器

如果我们需要使用纹理的话，那么纹理管理器就是必须设置的。

```C++
    world->SetTextureManager(TextureManager);
```

上面的参数是纹理管理器的地址，需要注意保持纹理管理器的生命周期。

### 设置地图

最后便是设置好我们的地图，同样也需要保持地图的生命周期。

```C++
    world->SetWorldMap(WorldMap);
```

参数是地图的地址。

### 设置世界

仅仅只是这样还不能够将世界呈现出来，我们还需要将我们的世界和我们的应用呈现关联。

```C++
    app->SetWorld(World);
```

## 一些注意事项以及样例

- 首先，对于参数是指针的，请注意保持其生命周期。也就是说，不能在我们还在使用他的时候，他就因为一些原因被销毁(例如局部变量会在结束的时候被销毁，提前`delete`了数据等等情况)。

- 样例地址: [EnginePixelWorld](https://github.com/LinkClinton/PixelWorldEngineSample/tree/master/EnginePixelWorld)